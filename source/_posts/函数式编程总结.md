title: 函数式编程
type:
  - tags
  - categories
date: 2017-03-13 14:25:51
tags:
categories:
---
# 引言
自react流行开来，函数式编程这个概念也跟着火了起来，记得去年面试时就问到了函数式编程的理解，当时对于函数式编程的理解只局限于自己开发过的一个react项目以及部分阅读过的文章而已，现在回想起来回答的真是不堪入目，所以在这之后好好的过了一遍相关概念，系统的了解一下函数式编程。
# 从bug产生的温床副作用讲起
程序员最怕出现的bug，但是bug为什么会出现呢？可能所有人得看法都不一样，可能是由于开发人员的水平所致，可能是软件的复杂度导致的等等。Franklin Risby教授认为bug产生的环境是副作用，副作用是bug产生的温床。什么是副作用呢？引用几个例子

> - 更改文件系统
> - 往数据库插入记录
> - 发送一个 http 请求
> - 可变数据
> - 打印/log
> - 获取用户输入
> - DOM 查询
> - 访问系统状态

概括来讲，只要是跟函数外部环境发生的交互就都是副作用。为什么bug容易在副环境中产生呢？简单来说因为外部环境是不可靠得，任何的变动都可能引起bug的产生，例如：
![外部环境依赖示例图](http://7xr8op.com1.z0.glb.clouddn.com/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%96%87%E6%A1%A3.png)
在这种情况下，当有新的开发者去开始依赖外部环境的方法D时，发现结果不是预期的，于是更改了外部环境的变量，虽然此时方法D是没有问题了，但是之前的方法ABC都出现了问题，这就是常见的修复了一个bug另一个地方又出现了bug。那么要怎样避免这种问题的出现呢？一个很直接的方法进行柯里化，将外部的环境变量转换为方法内部的变量，不依赖不可靠的外部环境。
![柯里化降低副作用](http://7xr8op.com1.z0.glb.clouddn.com/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%96%87%E6%A1%A3%20%281%29.png)
这样以来依赖不可靠的外部环境就会变成新方法内部的一个缓存下来的变量，当外部的环境发生变化的时候，起内部的缓存变量是不会变化的，减少副作用，这也是函数式编程的一个重要的点。
# 几个重要的基本概念
面向对象与函数式编程是一个相对的概念，如果说面向对象是通过人类的思维方式去解决软件工程里的难题的话，那么函数式编程就是通过数学的思维方式去解决软件工程里的问题。
学习函数式就像当初学习面向对象编程的感觉一样。有很多新的概念需要学习，但又与面向对象不一样，函数式编程里的概念要比面向对象里的概念抽象，毕竟是数学的思维，数学的本质就是抽象。下面就从几个重要的概念说起，来一步步的深入到函数式编程的精髓中。

## 纯函数
纯函数是函数式编程的基础，函数式编程是建立在一个个纯函数的基础上实现的，那么什么是纯函数呢？就像之前说的函数式编程是数学的思维方式，所以就先回顾下初中数学函数的概念吧。
> A function relates an input to an output.函数是不同数值之间的特殊关系：每一个输入值返回且只返回一个输出值。

函数有个重要的判断方式就是一个f(x)只能对应一个y，但是一个y可以对应多个f(x)，例如：
![function-sets](http://7xr8op.com1.z0.glb.clouddn.com/function-sets.gif)
上面这个图就是一个函数，而下面这个就不是，因为一个x对应了多个y
![http://7xr8op.com1.z0.glb.clouddn.com/relation-not-function.gif](http://7xr8op.com1.z0.glb.clouddn.com/relation-not-function.gif)

说完了数学里函数的概念，那么再说下什么是纯函数，纯函数的意思和数学里函数的概念一样，即相同的输入产生相同的输出，若是相同的输入产生了不同的输出那这个就不是纯函数，会产生副作用，因为这个函数是不可靠的，他的输出结果是不确定的。先从个简单的例子开始：
```
let age = 18;
let showAge = () => {
  console.log(age)
}
```
上面这个`showAge`函数就不是一个纯函数，因为相同的输入不一定会产生相同的输出，当外部变量age改变时其输出也就改变了，若是要改成纯函数吧age这个变量变成一个非外部变量即可
```
let showAge = () => {
  let age = 18;
  console.log(age)
}
```
这样一来这就是纯函数了，因为无论怎么调用这个函数，它的输出值是恒定不会改变的。
下面来一个稍微复杂点的。
```
let getUserInfo = AjaxGet('/getUserInfo',(json) =>{
  console.log(json);
}) 
```
上面这个函数就不是纯函数，因为调用了'/getUserInfo'这个接口返回的参数并不会是总是一样的，若是要把它编程纯函数，就需要用到柯里化，将这个函数改成惰性调用就可以了。
```
//ES6
let getUserInfo = (callback) => AjaxGet('/getUserInfo',callback)
ES5
var getUserInfo = function(callback) {
  return AjaxGet('/getUserInfo', callback);
};
```
通过改造后能够看出`getUserInfo`这个函数这个函数无论调用多少次它的返回都是不会改变的，那就是返回一个调用`/getUserInfo`的接口函数，这样依赖就将一个非纯函数改造成了一个纯函数。

## 柯里化（curry）
首先什么是柯里化呢？这个如果只是从单纯的从概念上讲还是挺抽象的，所以先从例子说起，最后在说下什么是柯里化，这样更容易让人理解。
柯里化是函数编程中另一个十分重要的概念，且在应用上十分的广泛和重要，使用柯里化不光可以将一个非纯函数改造成一个纯函数，即使不用来改造函数，在非函数式开发中也能给我们带来很大的便利。举个例子，在接口模块中我们常常会这么定义接口调用的函数：
```
//ES6
let getUserInfo = Ajaxget('/getUserInfo',(json) => json)
//ES5
var getUserInfo = AjaxGet('/getUserInfo',fcuntion(json){
  return json;
})

//ES6
let getItemInfo = Ajaxget('/getItemInfo',(json) => json)
//ES5
var getItemInfo = AjaxGet('/getItemInfo',fcuntion(json){
  return json;
})

//ES6
let getPrice = Ajaxget('/getPrice',(json) => json)
//ES5
var getPrice = AjaxGet('/getPrice',fcuntion(json){
  return json;
})

//......等等众接口
```
这样写看起来不错没什么问题，但是如果有一天接到变动说通信协议要变，对每个返回的json加上安全检测，那这改动就麻烦了，成了一个纯体力活。改动就成了
```
//ES6
let getUserInfo = $.getJson('/getUserInfo',(json) =>{
  if (isSecruity(json)){
    return callback
  } 
})
//ES5
var getUserInfo = $.getJson('/getUserInfo',fcuntion(json){
  if (isSecruity(json)){
    return callback
  } 
})
//...省略掉
```
使用了柯里化这个问题就变得简单了不少
```
//ES6
let getJson = (api,callback) => ajaxGet(api,callback)
//ES5
var getJson = function(api,callback){
  return ajaxGet(api,callback)
}

let getUserInfo = getJson('/getUserInfo')
let getItemInfo = getJson('/getItemInfo')
let getPrice = getJson('/getPrice')
```
对于上面提到的协议变动，我们只要对`getJson`这个柯里化函数做修改就可以了，其他的由`getJson`这个柯里化函数生出来的小函数都一个个的自动修改了。
```
//ES6
let getJson = (api,callback) => ajaxGet(api,(json)=>{
  if (isSecruity(json)){
    return callback
  } 
})
//ES5
var getJson = function(api,callback){
  return ajaxGet(api,function(json){
    if (isSecruity(json)){
      return callback
    } 
  })
}
```
通过例子可以看出柯里化就是
> 只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。

通过闭包将第一个参数缓存起来供给给返回的函数使用，使之成为一个新的函数。柯里化函数看起来就像小时候玩的小霸王游戏机一样，输入一个参数，也就是放入一个游戏机卡，它就会返回这个参数对应的函数，电视里就会出现这个游戏卡的游戏画面。

## 组合
组合是这个几个重要的基本概念中的最后一个，将组合之前要先从pointfree开始
### point-free
是的就是pointfree，没有对应的中文翻译名字。
> point-free又称作tacit-programming，是一种编程范式即不通过生命变量的形式声明函数。



# 遗漏部分
# 与面向对象的对比
# 参考
[http://www.mathsisfun.com/sets/function.html](http://www.mathsisfun.com/sets/function.html)