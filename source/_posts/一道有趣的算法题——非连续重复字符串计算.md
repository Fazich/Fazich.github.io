title: 一道有趣的算法题——非连续重复字符串计算
type:
  - tags
  - categories
date: 2017-03-29 15:30:18
tags: [算法]
categories: [js]
---
这是来自[freecodecamp](https://www.freecodecamp.cn/challenges/no-repeats-please)里的一道有趣的算法题，内容如下：
> 把一个字符串中的字符重新排列生成新的字符串，返回新生成的字符串里没有连续重复字符的字符串个数.连续重复只以单个字符为准。例如, aab 应该返回 2 因为它总共有6种排列 (aab, aab, aba, aba, baa, baa), 但是只有两个 (aba and aba)没有连续重复的字符 (在本例中是 a).

看到这个题的第一反应就是穷举遍历加判断的方式对这个问题进行求解，当然这个想法冒出来之后本能的直觉也告诉我这样做很愚蠢，会产生大量的无用功。

# 求解思路
仔细看看这道题用动态规划来解似乎是要好很多，对一个长度为n的字符串来说，它有n!种组合方式，在这n!种组合方式中如果有任意两个连续字符一样，那么就不符合题目要求的字符串。具体思路如下：

以“aab”这个字符为例，组合的时候会将这个字符串分成两个部分，一部分是基础为不变对对象，另一部分是交换对象。为了方便看，构建一个对象来存放这两个属性
```javascript
{
  immutable:[],
  swap:[]
}
```
例如“aab”会分为a,ab、a-],ab和b,aa这三块。如下所示:
```javascript
{
  immutable:[a],
  swap:[a,b]
}
{
  immutable:[a],
  swap:[a,b]
}
{
  immutable:[b],
  swap:[a,a]
}
```
以a,ab为例，在[a,b]这个组合中a是与不变部分相同，另一个是不同的，这就意味着在这个交换属性中，必然会存在一个连续的字符。接下来在从swap中的两个字符分成不变与可变部分
```
{
  immutable:[a],
  swap:[b]
}
```
两个不相等，这样一来就产生了一个符合要求字符串。

# 算法实现:
```javascript
function permAlone(str,lc) {
  if (str.length===0){
    return 1;
  }
  var res=0;
  for (var i=0; i<str.length; i++){
    if (str[i]!==lc){
      res+=permAlone(str.substring(0,i)+str.substring(i+1),str[i]);
    }
  }      
  return res;
}
```
这种分而治之的思想让这个复杂的问题变得更为的简单