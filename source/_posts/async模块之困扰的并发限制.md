title: async模块之困扰的并发限制
type:
  - tags
  - categories
date: 2016-12-16 20:21:27
tags: [js]
categories: [js]
---
async模块是一个管理异步上很强大的模块，使用这个模块可以很轻松的实现对回调并发的控制，例如顺序执行或者限制并发执行等等。但是在使用async模块时经常有一个困扰就是里面的callback，使用不当可能会导致使用中没有达到符合预期的样子，一个典型的例子就是在使用mapLimit时，执行到并发限制上限就终止了，而且不明原因，只能参考别人的代码把callback加上才能用，所以在这里写一下这个是怎么回事。

# 异步与同步
首先简述下同步与异步的概念，这是理解callback的一个很重要的基础。
## 同步
先从同步这个概念开始。同步根据名字就能大致猜出来其中的意思，意思就是在事物处理上只能按部就班一个个来的。以银行取钱为例，一排人在排队取钱，有的人取的快有的人取得慢，不管快也好还是慢也好，你只能等着前面的取完钱后才能轮到自己。

在浏览器加载网上的资源这个场景里同步是一件很可怕的事情，一个网页打开可能会请求很多资源图片文字声音等等，如果是同步执行的那就意味着一个资源下载完了才能下载另一个资源，一个大型网站优化不好的话可能要加载上百个资源文件，如果是同步的话那打开个网页的功夫你都可以撸完一局了。

听起来感觉同步效率很低啊，那为什么还要有同步呢？同步也有它优秀的地方，那就是好管理，这个和数据结构的队列很像先进先出嘛。

## 异步
接下来就是异步了。不讲概念丛场景入手，还是那个银行排队的场景，在刚才同步取钱的场景下已经看出了，效率很低，如果前面的人取钱的时候，正好还有其他事不能立刻取钱，占着取钱窗口不离开，那就醉了。所以异步就登场了帮你加快取钱速度。异步的处理是这样的，你前面的要取钱，但是工作人员说不行啊，你想取钱得复印下你的身份证，然后这个时候呢她就取复印身份证去了，然后你不用等她复印完回来就可以取钱了，因为她并没有就绪。这个时候你取完钱要走了，该轮到下一位了，但是这个时候你前面的那个人复印完回来了，这个时候就优先处理他了，后面的人肯定没意见吧。这就是异步取钱的场景。

还是那个浏览器加载资源的过程，使用了异步就立马提升体验了。在请求资源的时候，我们不用等上个资源请求完毕，直接去请求下一个资源，之后就是谁先请求完了再处理谁，这样是不是很快，最大程度的利用了带宽和CPU，跟操作系统里的一些概念蛮像的。

# async
接下在就是async了，本文将丛mapLimit这个方法入手，讲一下为什么使用mapLimit达到并发上限后就不执行了。
> mapLimit(arr, limit, iterator, callback) 

这就是那个方法的简单文档，其中这个四个参数的意思解释下。arr是一个数组对象，这里面包含着的是你处理的事件队列，比如在爬虫中这里面放的就是你要爬的url；limit就是并发限制，iteration是一个迭代器，它就是用来处理arr队列里资源的函数，callback就不用解释了回调函数，里面有两个参数一个是err另一个是result，iterator处理完arr里的资源后应该callback出来，出来的资源就是result。这块不大好说明，一会见代码吧，一眼就明白。

好了，简单介绍完之后就上代码了，先是一个十分简单的例子，简单到里面跟没有异步
```javascript
var async = require('async');

var arr = [];
for (var i = 1;i<100;i++){
    arr.push(i)
}

async.mapLimit(arr,5,function(item,callback){
        callback(null,item);
},function(err,result){
    console.log(result); //[1,2,3,....,99];
})
```
上面的代码执行的记过就是遍历了整个数组。那么上面的代码发生了什么呢？首先在执行的时候先丛arr里取处一个资源给iteratior来处里，在iteratior里的那个item就是arr交给迭代器的一个资源，在iterator这个函数处理完之后将会有一个callback(null,item),意思就是执行完毕了返回的第一个null对应的就是后面的err，第二个item对应的就是后面的result，所以输出了整个数组内容。至于那个arr呢，如果发现iterator异步的处理没有达到上限，那么它就会继续把资源交给iterator来处理。

上面说了一坨，来一句其中要害的，就是arr里的资源要交给iterator来处理，iterator处理完了要callback出来告诉arr，我处理完了有空缺位置，在给我一个来处理吧。

接下来我们把上面的代码加点内容，让它有异步的存在，看起来更真是一些，不然的那个limit岂不是成摆设了。
```javascript
var async = require('async');

var arr = [];
for (var i = 1;i<100;i++){
    arr.push(i)
}

var count = 0;

async.mapLimit(arr,5,function(item,callback){
    console.log('并发执行:'+count);
    count++;
    setTimeout(function(){
        callback(null,item);
        count--;
        console.log('并发执行:'+count);
    },1000)

},function(err,result){
    console.log(result);
})

```

上面这段代码更有真实感了，其实很简单，就是在callback的外面逃了一层settimeout，来模拟回调的执行，这样以来就能清晰的看到对并发的限制了。

# 最后

最后简而言之就是，在mapLimit达到上限后没有继续执行的根本原因就是，你少了callback，没有callback，async根本不知道你是否执行完毕，这样以来怎么能够获取arr里的资源呢





